{"version":3,"sources":["q.js","libs.min.js","/source/json-pointer.coffee","content-loader.js"],"names":["definition","bootstrap","exports","module","define","amd","ses","ok","makeQ","window","self","Error","global","previousQ","Q","noConflict","this","uncurryThis","f","call","apply","arguments","isObject","value","Object","isStopIteration","exception","object_toString","QReturnValue","makeStackTraceLong","error","promise","hasStacks","stack","indexOf","STACK_JUMP_SEPARATOR","stacks","p","source","unshift","concatedStacks","join","filterStackString","stackString","lines","split","desiredLines","i","length","line","isInternalFrame","isNodeFrame","push","stackLine","getFileNameAndLineNumber","attempt1","exec","Number","attempt2","attempt3","fileNameAndLineNumber","fileName","lineNumber","qFileName","qStartingLine","qEndingLine","captureLine","e","firstLine","deprecate","callback","name","alternative","console","warn","Promise","isPromiseAlike","coerce","fulfill","defer","become","newPromise","resolvedPromise","array_reduce","messages","undefined","message","nextTick","promiseDispatch","progressListeners","deferred","object_create","prototype","resolve","op","operands","args","array_slice","valueOf","nearerValue","nearer","isPromise","inspect","state","longStackSupport","substring","reject","reason","notify","progress","progressListener","resolver","TypeError","race","answerPs","len","then","descriptor","fallback","result","inspected","when","fulfilled","rejected","progressed","object","isPending","isFulfilled","isRejected","resetUnhandledRejections","unhandledReasons","unhandledRejections","trackUnhandledRejections","trackRejection","process","emit","runAfter","array_indexOf","reportedUnhandledRejections","untrackRejection","at","atReport","splice","rejection","get","set","rhs","delete","post","thisp","keys","object_keys","master","isDef","dispatch","spread","async","makeGenerator","continuer","verb","arg","StopIteration","generator","done","errback","bind","spawn","_return","promised","all","promises","pendingCount","index","snapshot","any","prev","current","onFulfilled","onRejected","onProgress","allResolved","array_map","noop","allSettled","nodeify","nodeback","flush","task","domain","head","next","enter","runSingle","laterQueue","pop","flushing","isNodeJS","exit","setTimeout","tail","requestTick","toString","setImmediate","MessageChannel","channel","port1","onmessage","requestPortTick","port2","postMessage","Function","Array","slice","reduce","basis","map","collect","create","Type","object_hasOwnProperty","hasOwnProperty","key","ReturnValue","env","Q_DEBUG","makeNodeResolver","passByCopy","x","y","that","makePromise","_fulfilled","_rejected","newException","_progressed","newValue","threw","onerror","tap","fcall","thenResolve","thenReject","getUnhandledReasons","stopUnhandledRejectionTracking","array","del","mapply","send","mcall","invoke","fapply","fbind","concat","regardless","fail","fin","onUnhandledError","timeout","ms","timeoutId","code","clearTimeout","delay","nfapply","nodeArgs","nfcall","nfbind","denodeify","baseArgs","nbind","bound","nmapply","npost","nsend","nmcall","ninvoke","root","factory","JSON","pointer","JsonPointer","JsonPointerError","extend","child","parent","ctor","constructor","hasProp1","__super__","superClass","base","smartBind","api","frag","hasObj","hasOpt","hasPtr","mergeOptions","obj","opt","ptr","val","fragment","options","parse","override","o","ref","ref1","ref2","ref3","ref4","ref5","hasOwnProp","getProp","setProp","getNotFound","setNotFound","delNotFound","has","compilePointer","parsePointer","compileFragment","parseFragment","escape","segment","replace","escapeFragment","encodeURIComponent","unescape","unescapeFragment","decodeURIComponent","isPointer","str","charAt","isFragment","compile","segments","hasJsonProp","isArray","hasProp","iSegment","match","errorNotFound","parseInt","card","getParams","kvps","keyValuePair","parts","location","href","paramMap","paramMapKeys","getImageUrl","image","defaultHost","endpoint","type","mediaType","fetch","parseJson","data","finishLoading","loader","document","querySelector","classList","add","src","getQueryVar","ajaxGet","loadSchema","setCardMeta","produceMap","log","trimString","inlineChildContent","parentNode","contentMap","lineage","forEach","childKey","item","schema","content","inlineContent","params","utils","cardId","meta","id","buildMapping","mapping","query","getQueryVars","param","mapData","mapped","requestedContent","@id","schemas","variable","search","vars","pair","parseUrl","elm","createElement","protocol","hostname","port","pathname","hash","host","parseString","sanitize","SURROGATE_PAIR_REGEXP","NON_ALPHANUMERIC_REGEXP","hi","charCodeAt","low","path","def","xhr","XMLHttpRequest","onreadystatechange","readyState","DONE","status","responseText","open"],"mappings":"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","file":"libs.min.js","sourcesContent":["// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.nextTick()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you don’t need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Miller’s explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n        promise.source = newPromise;\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If it’s a fulfilled promise, the fulfillment value is nearer.\n * If it’s a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected() {\n            pendingCount--;\n            if (pendingCount === 0) {\n                deferred.reject(new Error(\n                    \"Can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected.\"\n                ));\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n",null,"class JsonPointerError extends Error\r\n  constructor: (message) ->\r\n    base = super(message)\r\n\r\n    @message = base.message\r\n    @stack = base.stack\r\n    @name = @constructor.name\r\n\r\nclass JsonPointer\r\n  @JsonPointerError: JsonPointerError\r\n\r\n  ###\r\n  # Convenience function for choosing between `.smartBind`, `.get`, and `.set`, depending on the number of arguments.\r\n  #\r\n  # @param {*} object\r\n  # @param {string} pointer\r\n  # @param {*} value\r\n  # @returns {*} evaluation of the proxied method\r\n  ###\r\n  constructor: (object, pointer, value) ->\r\n    return switch arguments.length\r\n      when 3 then JsonPointer.set(object, pointer, value)\r\n      when 2 then JsonPointer.get(object, pointer)\r\n      when 1 then JsonPointer.smartBind({ object: object })\r\n      else null\r\n\r\n  ###\r\n  # Creates a clone of the api, with `./.get/.has/.set/.del/.smartBind` method signatures adjusted.\r\n  # The smartBind method is cumulative, meaning that `.smartBind({ object: x}).smartBind({ pointer: y })` will behave as expected.\r\n  #\r\n  # @param {Object} bindings\r\n  # @param {*} bindings.object\r\n  # @param {string|string[]} bindings.pointer\r\n  # @param {Object} bindings.options\r\n  # @returns {JsonPointer}\r\n  ###\r\n  @smartBind: ({ object: obj, pointer: ptr, fragment: frag, options: opt }) ->\r\n    # fragment overrides pointer\r\n    ptr = frag ? ptr\r\n\r\n    # What are binding?\r\n    hasObj = obj != undefined\r\n    hasPtr = ptr?\r\n    hasOpt = opt?\r\n\r\n    # Lets not parse this every time!\r\n    if typeof ptr == 'string'\r\n      ptr = @parse(ptr)\r\n\r\n    # default options have changed\r\n    mergeOptions = (override = {}) ->\r\n      o = {}\r\n\r\n      o.hasOwnProp = override.hasOwnProp ? opt.hasOwnProp\r\n      o.getProp = override.getProp ? opt.getProp\r\n      o.setProp = override.setProp ? opt.setProp\r\n      o.getNotFound = override.getNotFound ? opt.getNotFound\r\n      o.setNotFound = override.setNotFound ? opt.setNotFound\r\n      o.delNotFound = override.delNotFound ? opt.delNotFound\r\n\r\n      return o\r\n\r\n    api = undefined\r\n\r\n    # Every combination of bindings\r\n    if hasObj and hasPtr and hasOpt\r\n      api = (value) ->\r\n        return switch arguments.length\r\n          when 1 then JsonPointer.set(obj, ptr, value, opt)\r\n          when 0 then JsonPointer.get(obj, ptr, opt)\r\n          else null\r\n\r\n      api.set = (value, override) -> obj = JsonPointer.set(obj, ptr, value, mergeOptions(override))\r\n      api.get = (override) -> JsonPointer.get(obj, ptr, mergeOptions(override))\r\n      api.has = (override) -> JsonPointer.has(obj, ptr, mergeOptions(override))\r\n      api.del = (override) -> obj = JsonPointer.del(obj, ptr, mergeOptions(override))\r\n    else if hasObj and hasPtr\r\n      api = (value) ->\r\n        return switch arguments.length\r\n          when 1 then JsonPointer.set(obj, ptr, value)\r\n          when 0 then JsonPointer.get(obj, ptr)\r\n          else null\r\n\r\n      api.set = (value, override) -> obj = JsonPointer.set(obj, ptr, value, override)\r\n      api.get = (override) -> JsonPointer.get(obj, ptr, override)\r\n      api.has = (override) -> JsonPointer.has(obj, ptr, override)\r\n      api.del = (override) -> obj = JsonPointer.del(obj, ptr, override)\r\n    else if hasObj and hasOpt\r\n      api = (ptr, value) ->\r\n        return switch arguments.length\r\n          when 2 then JsonPointer.set(obj, ptr, value, opt)\r\n          when 1 then JsonPointer.get(obj, ptr, opt)\r\n          else null\r\n\r\n      api.set = (ptr, value, override) -> obj = JsonPointer.set(obj, ptr, value, mergeOptions(override))\r\n      api.get = (ptr, override) -> JsonPointer.get(obj, ptr, mergeOptions(override))\r\n      api.has = (ptr, override) -> JsonPointer.has(obj, ptr, mergeOptions(override))\r\n      api.del = (ptr, override) -> obj = JsonPointer.del(obj, ptr, mergeOptions(override))\r\n    else if hasPtr and hasOpt\r\n      api = (obj, value) ->\r\n        return switch arguments.length\r\n          when 2 then JsonPointer.set(obj, ptr, value, opt)\r\n          when 1 then JsonPointer.get(obj, ptr, opt)\r\n          else null\r\n\r\n      api.set = (obj, value, override) -> JsonPointer.set(obj, ptr, value, mergeOptions(override))\r\n      api.get = (obj, override) -> JsonPointer.get(obj, ptr, mergeOptions(override))\r\n      api.has = (obj, override) -> JsonPointer.has(obj, ptr, mergeOptions(override))\r\n      api.del = (obj, override) -> JsonPointer.del(obj, ptr, mergeOptions(override))\r\n    else if hasOpt\r\n      api = (obj, ptr, value) ->\r\n        return switch arguments.length\r\n          when 3 then JsonPointer.set(obj, ptr, value, opt)\r\n          when 2 then JsonPointer.get(obj, ptr, opt)\r\n          when 1 then api.smartBind({ object: obj })\r\n          else null\r\n\r\n      api.set = (obj, ptr, value, override) -> JsonPointer.set(obj, ptr, value, mergeOptions(override))\r\n      api.get = (obj, ptr, override) -> JsonPointer.get(obj, ptr, mergeOptions(override))\r\n      api.has = (obj, ptr, override) -> JsonPointer.has(obj, ptr, mergeOptions(override))\r\n      api.del = (obj, ptr, override) -> JsonPointer.del(obj, ptr, mergeOptions(override))\r\n    else if hasObj\r\n      api = (ptr, value) ->\r\n        return switch arguments.length\r\n          when 2 then JsonPointer.set(obj, ptr, value)\r\n          when 1 then JsonPointer.get(obj, ptr)\r\n          else null\r\n\r\n      api.set = (ptr, value, override) -> obj = JsonPointer.set(obj, ptr, value, override)\r\n      api.get = (ptr, override) -> JsonPointer.get(obj, ptr, override)\r\n      api.has = (ptr, override) -> JsonPointer.has(obj, ptr, override)\r\n      api.del = (ptr, override) -> obj = JsonPointer.del(obj, ptr, override)\r\n    else if hasPtr\r\n      api = (obj, value) ->\r\n        return switch arguments.length\r\n          when 2 then JsonPointer.set(obj, ptr, value)\r\n          when 1 then JsonPointer.get(obj, ptr)\r\n          else null\r\n\r\n      api.set = (obj, value, override) -> JsonPointer.set(obj, ptr, value, override)\r\n      api.get = (obj, override) -> JsonPointer.get(obj, ptr, override)\r\n      api.has = (obj, override) -> JsonPointer.has(obj, ptr, override)\r\n      api.del = (obj, override) -> JsonPointer.del(obj, ptr, override)\r\n    else\r\n      return @\r\n\r\n    # smartBind has new defaults\r\n    api.smartBind = (override) ->\r\n      o = {}\r\n\r\n      if {}.hasOwnProperty.call(override, 'object')\r\n        o.object = override.object\r\n      else if hasObj\r\n        o.object = obj\r\n\r\n      if {}.hasOwnProperty.call(override, 'pointer')\r\n        o.pointer = override.pointer\r\n      else if hasPtr\r\n        o.pointer = ptr\r\n\r\n      if {}.hasOwnProperty.call(override, 'options')\r\n        o.options = mergeOptions(override.options)\r\n      else if hasObj\r\n        o.options = opt\r\n\r\n      return JsonPointer.smartBind(o)\r\n\r\n    if hasPtr\r\n      ###\r\n      # get/set bound pointer value\r\n      #\r\n      # Only available when pointer has been bound\r\n      #\r\n      # @param {string} value\r\n      # @returns string[] segments\r\n      ###\r\n      api.pointer = (value) ->\r\n        if arguments.length == 0\r\n          return JsonPointer.compilePointer(ptr)\r\n        else\r\n          return ptr = JsonPointer.parsePointer(value)\r\n\r\n      ###\r\n      # get/set bound pointer value as fragment\r\n      #\r\n      # Only available when pointer has been bound\r\n      #\r\n      # @param {string} value\r\n      # @returns string[] segments\r\n      ###\r\n      api.fragment = (value) ->\r\n        if arguments.length == 0\r\n          return JsonPointer.compileFragment(ptr)\r\n        else\r\n          return ptr = JsonPointer.parseFragment(value)\r\n\r\n    if hasObj\r\n      ###\r\n      # get/set bound object\r\n      #\r\n      # Only available when object has been bound\r\n      #\r\n      # @param {*} value\r\n      # @returns {*} bound object\r\n      ###\r\n      api.object = (value) ->\r\n        if arguments.length == 0\r\n          return obj\r\n        else\r\n          return obj = value\r\n\r\n    if hasOpt\r\n      ###\r\n      # get/set bound options\r\n      #\r\n      # Only available when options has been bound\r\n      #\r\n      # @param {*} value\r\n      # @returns {*} bound options\r\n      ###\r\n      api.options = (value) ->\r\n        if arguments.length == 0\r\n          return opt\r\n        else\r\n          return opt = value\r\n\r\n    # copy the remaining methods which do not need binding\r\n    for own key, val of JsonPointer\r\n      if not {}.hasOwnProperty.call(api, key)\r\n        api[key] = val\r\n\r\n    # final result\r\n    return api\r\n\r\n  ###\r\n  # Escapes the given path segment as described by RFC6901.\r\n  #\r\n  # Notably, `'~'`'s are replaced with `'~0'` and `'/'`'s are replaced with `'~1'`.\r\n  #\r\n  # @param {string} segment\r\n  # @returns {string}\r\n  ###\r\n  @escape: (segment) ->\r\n    segment.replace(/~/g, '~0').replace(/\\//g, '~1')\r\n\r\n  ###\r\n  # Escapes the given path fragment segment as described by RFC6901.\r\n  #\r\n  # Notably, `'~'`'s are replaced with `'~0'` and `'/'`'s are replaced with `'~1'` and finally the string is URI encoded.\r\n  #\r\n  # @param {string} segment\r\n  # @returns {string}\r\n  ###\r\n  @escapeFragment: (segment) ->\r\n    encodeURIComponent(JsonPointer.escape(segment))\r\n\r\n  ###\r\n  # Un-Escapes the given path segment, reversing the actions of `.escape`.\r\n  #\r\n  # Notably, `'~1'`'s are replaced with `'/'` and `'~0'`'s are replaced with `'~'`.\r\n  #\r\n  # @param {string} segment\r\n  # @returns {string}\r\n  ###\r\n  @unescape: (segment) ->\r\n    segment.replace(/~1/g, '/').replace(/~0/g, '~')\r\n\r\n  ###\r\n  # Un-Escapes the given path fragment segment, reversing the actions of `.escapeFragment`.\r\n  #\r\n  # Notably, the string is URI decoded and then `'~1'`'s are replaced with `'/'` and `'~0'`'s are replaced with `'~'`.\r\n  #\r\n  # @param {string} segment\r\n  # @returns {string}\r\n  ###\r\n  @unescapeFragment: (segment) ->\r\n    JsonPointer.unescape(decodeURIComponent(segment))\r\n\r\n  ###\r\n  # Returns true iff `str` is a valid json pointer value\r\n  #\r\n  # @param {string} str\r\n  # @returns {Boolean}\r\n  ###\r\n  @isPointer: (str) ->\r\n    switch str.charAt(0)\r\n      when '' then return true\r\n      when '/' then return true\r\n      else\r\n        return false\r\n\r\n  ###\r\n  # Returns true iff `str` is a valid json fragment pointer value\r\n  #\r\n  # @param {string} str\r\n  # @returns {Boolean}\r\n  ###\r\n  @isFragment: (str) ->\r\n    switch str.substring(0, 2)\r\n      when '#' then return true\r\n      when '#/' then return true\r\n      else\r\n        return false\r\n\r\n  ###\r\n  # Parses a json-pointer or json fragment pointer, as described by RFC901, into an array of path segments.\r\n  #\r\n  # @throws {JsonPointerError} for invalid json-pointers.\r\n  #\r\n  # @param {string} str\r\n  # @returns {string[]}\r\n  ###\r\n  @parse: (str) ->\r\n    switch str.charAt(0)\r\n      when '' then return []\r\n      when '/' then return str.substring(1).split('/').map(JsonPointer.unescape)\r\n      when '#'\r\n        switch str.charAt(1)\r\n          when '' then return []\r\n          when '/' then return str.substring(2).split('/').map(JsonPointer.unescapeFragment)\r\n          else\r\n            throw new JsonPointerError(\"Invalid JSON fragment pointer: #{str}\")\r\n      else\r\n        throw new JsonPointerError(\"Invalid JSON pointer: #{str}\")\r\n\r\n  ###\r\n  # Parses a json-pointer, as described by RFC901, into an array of path segments.\r\n  #\r\n  # @throws {JsonPointerError} for invalid json-pointers.\r\n  #\r\n  # @param {string} str\r\n  # @returns {string[]}\r\n  ###\r\n  @parsePointer: (str) ->\r\n    switch str.charAt(0)\r\n      when '' then return []\r\n      when '/' then return str.substring(1).split('/').map(JsonPointer.unescape)\r\n      else throw new JsonPointerError(\"Invalid JSON pointer: #{str}\")\r\n\r\n  ###\r\n  # Parses a json fragment pointer, as described by RFC901, into an array of path segments.\r\n  #\r\n  # @throws {JsonPointerError} for invalid json-pointers.\r\n  #\r\n  # @param {string} str\r\n  # @returns {string[]}\r\n  ###\r\n  @parseFragment: (str) ->\r\n    switch str.substring(0, 2)\r\n      when '#' then return []\r\n      when '#/' then return str.substring(2).split('/').map(JsonPointer.unescapeFragment)\r\n      else\r\n        throw new JsonPointerError(\"Invalid JSON fragment pointer: #{str}\")\r\n\r\n  ###\r\n  # Converts an array of path segments into a json pointer.\r\n  # This method is the reverse of `.parsePointer`.\r\n  #\r\n  # @param {string[]} segments\r\n  # @returns {string}\r\n  ###\r\n  @compile: (segments) ->\r\n    segments.map((segment) -> '/' + JsonPointer.escape(segment)).join('')\r\n\r\n  ###\r\n  # Converts an array of path segments into a json pointer.\r\n  # This method is the reverse of `.parsePointer`.\r\n  #\r\n  # @param {string[]} segments\r\n  # @returns {string}\r\n  ###\r\n  @compilePointer: (segments) ->\r\n    segments.map((segment) -> '/' + JsonPointer.escape(segment)).join('')\r\n\r\n  ###\r\n  # Converts an array of path segments into a json fragment pointer.\r\n  # This method is the reverse of `.parseFragment`.\r\n  #\r\n  # @param {string[]} segments\r\n  # @returns {string}\r\n  ###\r\n  @compileFragment: (segments) ->\r\n    '#' + segments.map((segment) -> '/' + JsonPointer.escapeFragment(segment)).join('')\r\n\r\n  ###\r\n  # Callback used to determine if an object contains a given property.\r\n  #\r\n  # @callback hasProp\r\n  # @param {*} obj\r\n  # @param {string|integer} key\r\n  # @returns {Boolean}\r\n  ###\r\n\r\n  ###\r\n  # Returns true iff `obj` contains `key` and `obj` is either an Array or an Object.\r\n  # Ignores the prototype chain.\r\n  #\r\n  # Default value for `options.hasProp`.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|integer} key\r\n  # @returns {Boolean}\r\n  ###\r\n  @hasJsonProp: (obj, key) ->\r\n    if Array.isArray(obj)\r\n      return (typeof key == 'number') and (key < obj.length)\r\n    else if typeof obj == 'object'\r\n      return {}.hasOwnProperty.call(obj, key)\r\n    else\r\n      return false\r\n\r\n  ###\r\n  # Returns true iff `obj` contains `key`, disregarding the prototype chain.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|integer} key\r\n  # @returns {Boolean}\r\n  ###\r\n  @hasOwnProp: (obj, key) ->\r\n    {}.hasOwnProperty.call(obj, key)\r\n\r\n  ###\r\n  # Returns true iff `obj` contains `key`, including via the prototype chain.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|integer} key\r\n  # @returns {Boolean}\r\n  ###\r\n  @hasProp: (obj, key) ->\r\n    key of obj\r\n\r\n  ###\r\n  # Callback used to retrieve a property from an object\r\n  #\r\n  # @callback getProp\r\n  # @param {*} obj\r\n  # @param {string|integer} key\r\n  # @returns {*}\r\n  ###\r\n\r\n  ###\r\n  # Finds the given `key` in `obj`.\r\n  #\r\n  # Default value for `options.getProp`.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|integer} key\r\n  # @returns {*}\r\n  ###\r\n  @getProp: (obj, key) ->\r\n    obj[key]\r\n\r\n  ###\r\n  # Callback used to set a property on an object.\r\n  #\r\n  # @callback setProp\r\n  # @param {*} obj\r\n  # @param {string|integer} key\r\n  # @param {*} value\r\n  # @returns {*}\r\n  ###\r\n\r\n  ###\r\n  # Sets the given `key` in `obj` to `value`.\r\n  #\r\n  # Default value for `options.setProp`.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|integer} key\r\n  # @param {*} value\r\n  # @returns {*} `value`\r\n  ###\r\n  @setProp: (obj, key, value) ->\r\n    obj[key] = value\r\n\r\n  ###\r\n  # Callback used to modify behaviour when a given path segment cannot be found.\r\n  #\r\n  # @callback notFound\r\n  # @param {*} obj\r\n  # @param {string|integer} key\r\n  # @returns {*}\r\n  ###\r\n\r\n  ###\r\n  # Returns the value to use when `.get` fails to locate a pointer segment.\r\n  #\r\n  # Default value for `options.getNotFound`.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|integer} segment\r\n  # @param {*} root\r\n  # @param {string[]} segments\r\n  # @param {integer} iSegment\r\n  # @returns {undefined}\r\n  ###\r\n  @getNotFound: (obj, segment, root, segments, iSegment) ->\r\n    undefined\r\n\r\n  ###\r\n  # Returns the value to use when `.set` fails to locate a pointer segment.\r\n  #\r\n  # Default value for `options.setNotFound`.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|integer} segment\r\n  # @param {*} root\r\n  # @param {string[]} segments\r\n  # @param {integer} iSegment\r\n  # @returns {undefined}\r\n  ###\r\n  @setNotFound: (obj, segment, root, segments, iSegment) ->\r\n    if segments[iSegment + 1].match(/^(?:0|[1-9]\\d*|-)$/)\r\n      return obj[segment] = []\r\n    else\r\n      return obj[segment] = {}\r\n\r\n  ###\r\n  # Performs an action when `.del` fails to locate a pointer segment.\r\n  #\r\n  # Default value for `options.delNotFound`.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|integer} segment\r\n  # @param {*} root\r\n  # @param {string[]} segments\r\n  # @param {integer} iSegment\r\n  # @returns {undefined}\r\n  ###\r\n  @delNotFound: (obj, segment, root, segments, iSegment) ->\r\n    undefined\r\n\r\n  ###\r\n  # Raises a JsonPointerError when the given pointer segment is not found.\r\n  #\r\n  # May be used in place of the above methods via the `options` argument of `./.get/.set/.has/.del/.simpleBind`.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|integer} segment\r\n  # @param {*} root\r\n  # @param {string[]} segments\r\n  # @param {integer} iSegment\r\n  # @returns {undefined}\r\n  ###\r\n  @errorNotFound: (obj, segment, root, segments, iSegment) ->\r\n    throw new JsonPointerError(\"Unable to find json path: #{JsonPointer.compile(segments.slice(0, iSegment+1))}\")\r\n\r\n  ###\r\n  # Sets the location in `object`, specified by `pointer`, to `value`.\r\n  # If `pointer` refers to the whole document, `value` is returned without modifying `object`,\r\n  # otherwise, `object` modified and returned.\r\n  #\r\n  # By default, if any location specified by `pointer` does not exist, the location is created using objects and arrays.\r\n  # Arrays are used only when the immediately following path segment is an array element as defined by the standard.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|string[]} pointer\r\n  # @param {Object} options\r\n  # @param {hasProp} options.hasProp\r\n  # @param {getProp} options.getProp\r\n  # @param {setProp} options.setProp\r\n  # @param {notFound} options.getNotFound\r\n  # @returns {*}\r\n  ###\r\n  @set: (obj, pointer, value, options) ->\r\n    if typeof pointer == 'string'\r\n      pointer = JsonPointer.parse(pointer)\r\n\r\n    if pointer.length == 0\r\n      return value\r\n\r\n    hasProp = options?.hasProp ? JsonPointer.hasJsonProp\r\n    getProp = options?.getProp ? JsonPointer.getProp\r\n    setProp = options?.setProp ? JsonPointer.setProp\r\n    setNotFound = options?.setNotFound ? JsonPointer.setNotFound\r\n\r\n    root = obj\r\n    iSegment = 0\r\n    len = pointer.length\r\n\r\n    while iSegment != len\r\n      segment = pointer[iSegment]\r\n      ++iSegment\r\n\r\n      if segment == '-' and Array.isArray(obj)\r\n        segment = obj.length\r\n      else if segment.match(/^(?:0|[1-9]\\d*)$/) and Array.isArray(obj)\r\n        segment = parseInt(segment, 10)\r\n\r\n      if iSegment == len\r\n        setProp(obj, segment, value)\r\n        break\r\n      else if not hasProp(obj, segment)\r\n        obj = setNotFound(obj, segment, root, pointer, iSegment - 1)\r\n      else\r\n        obj = getProp(obj, segment)\r\n\r\n    return root\r\n\r\n  ###\r\n  # Finds the value in `obj` as specified by `pointer`\r\n  #\r\n  # By default, returns undefined for values which cannot be found\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|string[]} pointer\r\n  # @param {Object} options\r\n  # @param {hasProp} options.hasProp\r\n  # @param {getProp} options.getProp\r\n  # @param {notFound} options.getNotFound\r\n  # @returns {*}\r\n  ###\r\n  @get: (obj, pointer, options) ->\r\n    if typeof pointer == 'string'\r\n      pointer = JsonPointer.parse(pointer)\r\n\r\n    hasProp = options?.hasProp ? JsonPointer.hasJsonProp\r\n    getProp = options?.getProp ? JsonPointer.getProp\r\n    getNotFound = options?.getNotFound ? JsonPointer.getNotFound\r\n\r\n    root = obj\r\n    iSegment = 0\r\n    len = pointer.length\r\n    while iSegment != len\r\n      segment = pointer[iSegment]\r\n      ++iSegment\r\n\r\n      if segment == '-' and Array.isArray(obj)\r\n        segment = obj.length\r\n      else if segment.match(/^(?:0|[1-9]\\d*)$/) and Array.isArray(obj)\r\n        segment = parseInt(segment, 10)\r\n\r\n      if not hasProp(obj, segment)\r\n        return getNotFound(obj, segment, root, pointer, iSegment - 1)\r\n      else\r\n        obj = getProp(obj, segment)\r\n\r\n    return obj\r\n\r\n  ###\r\n  # Removes the location, specified by `pointer`, from `object`.\r\n  # Returns the modified `object`, or undefined if the `pointer` is empty.\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|string[]} pointer\r\n  # @param {Object} options\r\n  # @param {hasProp} options.hasProp\r\n  # @param {getProp} options.getProp\r\n  # @param {notFound} options.delNotFound\r\n  # @returns {*}\r\n  ###\r\n  @del: (obj, pointer, options) ->\r\n    if typeof pointer == 'string'\r\n      pointer = JsonPointer.parse(pointer)\r\n\r\n    if pointer.length == 0\r\n      return undefined\r\n\r\n    hasProp = options?.hasProp ? JsonPointer.hasJsonProp\r\n    getProp = options?.getProp ? JsonPointer.getProp\r\n    delNotFound = options?.delNotFound ? JsonPointer.delNotFound\r\n\r\n    root = obj\r\n    iSegment = 0\r\n    len = pointer.length\r\n    while iSegment != len\r\n      segment = pointer[iSegment]\r\n      ++iSegment\r\n\r\n      if segment == '-' and Array.isArray(obj)\r\n        segment = obj.length\r\n      else if segment.match(/^(?:0|[1-9]\\d*)$/) and Array.isArray(obj)\r\n        segment = parseInt(segment, 10)\r\n\r\n      if not hasProp(obj, segment)\r\n        delNotFound(obj, segment, root, pointer, iSegment - 1)\r\n        break\r\n      else if iSegment == len\r\n        delete obj[segment]\r\n        break\r\n      else\r\n        obj = getProp(obj, segment)\r\n\r\n    return root\r\n\r\n  ###\r\n  # Returns true iff the location, specified by `pointer`, exists in `object`\r\n  #\r\n  # @param {*} obj\r\n  # @param {string|string[]} pointer\r\n  # @param {Object} options\r\n  # @param {hasProp} options.hasProp\r\n  # @param {getProp} options.getProp\r\n  # @returns {*}\r\n  ###\r\n  @has: (obj, pointer, options) ->\r\n    if typeof pointer == 'string'\r\n      pointer = JsonPointer.parse(pointer)\r\n\r\n    hasProp = options?.hasProp ? JsonPointer.hasJsonProp\r\n    getProp = options?.getProp ? JsonPointer.getProp\r\n\r\n    iSegment = 0\r\n    len = pointer.length\r\n    while iSegment != len\r\n      segment = pointer[iSegment]\r\n      ++iSegment\r\n\r\n      if segment == '-' and Array.isArray(obj)\r\n        segment = obj.length\r\n      else if segment.match(/^(?:0|[1-9]\\d*)$/) and Array.isArray(obj)\r\n        segment = parseInt(segment, 10)\r\n\r\n      if not hasProp(obj, segment)\r\n        return false\r\n\r\n      obj = getProp(obj, segment)\r\n\r\n    return true\r\n","(function(card) {\n    card.meta = undefined; // this should be set post fetch process with the meta data for the current card\n\n    card.content = (function(){\n        return {\n            fetch: fetch,\n            mapData: mapData\n        };\n    }());\n\n    card.utils = (function(){\n        return {\n            parseUrl: parseUrl,\n            getQueryVar: getQueryVar,\n            ajaxGet: ajaxGet,\n            getImageUrl: getImageUrl,\n            parseString: parseString,\n            trimString: trimString,\n            getParams: getParams\n        };\n    }());\n\n    function getParams() {\n        var parts = window.location.href.split('?');\n        var kvps;\n        var keyValuePair;\n        var paramMap = {};\n        var i;\n        var len;\n\n        if (parts.length === 2) {\n            kvps = parts[1].split('&');\n\n            for (i = 0, len = kvps.length; i < len; i++) {\n                keyValuePair = kvps[i].split('=');\n                if (keyValuePair.length === 2) {\n                    if (paramMap[keyValuePair[0]]) {\n                        paramMap[keyValuePair[0]].push(decodeURIComponent(keyValuePair[1]));\n                    } else {\n                        paramMap[keyValuePair[0]] = [decodeURIComponent(keyValuePair[1])];\n                    }\n                }\n            }\n        }\n\n        var paramMapKeys = Object.keys(paramMap);\n        if (paramMapKeys.length) {\n            for (i = 0, len = paramMapKeys.length; i < len; i++) {\n                if (paramMap[paramMapKeys[i]].length === 1) {\n                    // make it a literal\n                    paramMap[paramMapKeys[i]] = paramMap[paramMapKeys[i]][0];\n                }\n            }\n        }\n\n        return paramMap;\n    }\n\n    function getImageUrl(image){\n        if(!image || !(image.defaultHost && image.endpoint && image.name)){\n            return false;\n        }\n        var type = image.mediaType === 'image' ? 'i' : 'v';\n        if(image.endpoint == 'portal') {\n            type = 'url';\n        }\n        return '//'+image.defaultHost+'/'+type+'/'+image.endpoint+'/'+image.name;\n    }\n\n    function fetch(){\n        var src = getQueryVar('src');\n        if(!src){\n            console.log('no content `src` param!');\n            return;\n        }\n\n        return ajaxGet(src)\n            .then(parseJson)\n            .then(loadSchema)\n            .then(setCardMeta)\n            .then(produceMap)\n            .then(finishLoading);\n\n        function parseJson(data) {\n            return JSON.parse(data);\n        }\n\n        function finishLoading(data){\n            var loader = document.querySelector('.loader');\n            var card = document.querySelector('.card');\n            if(loader){\n                loader.classList.add('hide');\n                card.classList.add('loaded');\n            }\n            return data;\n        }\n    }\n\n    function trimString(str,length) {\n        if(!str || typeof str !== 'string'){\n            return '';\n        }\n        if(str.length<=length){\n            return str;\n        } else {\n            return str.substring(0, length)+'&hellip;';\n        }\n\n    }\n\n    function inlineChildContent(parentNode, contentMap, lineage){\n        lineage = lineage || [];\n        Object.keys(parentNode).forEach(function(key){\n            var value = parentNode[key];\n            if(key === '@id' && contentMap[value]) {\n                if (lineage.indexOf(value) === -1) {\n                    Object.keys(contentMap[value]).forEach(function(childKey){\n                        parentNode[childKey] = contentMap[value][childKey];\n                    });\n                    lineage.push(value);\n                } else {\n                    console.log('circular dependency found ', value, ' already parsed higer up in chain.');\n                }\n            }\n        });\n        Object.keys(parentNode).forEach(function(key){\n            var value = parentNode[key];\n            if(value !== null && typeof value === 'object'){\n                parentNode[key] = inlineChildContent(parentNode[key], contentMap, lineage);\n            }else if(Array.isArray(value)){\n                value.forEach(function(item, i){\n                    parentNode[key][i] = inlineChildContent(parentNode[key][i], contentMap, lineage);\n                });\n            }\n        });\n        return parentNode;\n    }\n\n    function setCardMeta(data) {\n\n        //CMS 2 response\n        if(!data.schema){\n            return data;\n        }\n\n        // determines which card meta data should be used and sets `card.meta` accordingly\n        var content = data.inlineContent;\n        var schema = data.schema[content[\"@type\"]];\n        var params = card.utils.getParams();\n        var cardId = params.cardId;\n\n        // Polyfill\n        if (!Array.isArray) {\n            Array.isArray = function(arg) {\n                return Object.prototype.toString.call(arg) === '[object Array]';\n            };\n        }\n\n        if (Array.isArray(schema.meta.card)) {\n            if (cardId) {\n                for (var i = 0, len = schema.meta.card.length; i < len; i++) {\n                    if (schema.meta.card[i].id === cardId) {\n                        card.meta = schema.meta.card[i];\n                        break;\n                    }\n                }\n            } else {\n                console.log('schema uses a multi-card definition, but no `cardId` was passed in the card request params.');\n            }\n        } else {\n            card.meta = schema.meta.card;\n        }\n\n        // pass-through the data to the next step in the process\n        return data;\n    }\n\n    function buildMapping(card) {\n        var map = (card.meta && card.meta.mapping) || {};\n        var query = getQueryVars();\n\n        for(var i=0; i < query.length; i++) {\n            var param = query[i];\n            if(param.key !== 'src' && param.key !== 'cardId' && param.key !== 'templateUrl') {\n                map[param.key] = param.value;\n            }\n        }\n\n        return map;\n    }\n\n    function produceMap(data) {\n        var map;\n        var content = data.inlineContent;\n\n        map = buildMapping(card);\n\n        return mapData(map, content);\n    }\n\n    function mapData(map, content){\n        var mapped = {};\n\n        // if there is no mapping, just return the content to the rendering process\n        if (!map || Object.keys(map).length === 0) {\n            return content;\n        }\n\n        Object.keys(map).forEach(function(key){\n            var mapping = map[key];\n            if(Array.isArray(mapping)){\n                for(var i = 0; i < mapping.length; i++){\n                    if(JSON.pointer.has(content, mapping[i])){\n                        mapped[key] = JSON.pointer.get(content, mapping[i]);\n                        break;\n                    }\n                }\n            }else{\n                try {\n                    mapped[key] = JSON.pointer.get(content, mapping);\n                } catch(e) {} \n            }\n        });\n\n        return mapped;\n    }\n\n    function loadSchema(content){\n        var contentMap = {};\n        content['@graph'].forEach(function(content){\n            if(content && content['@id']){\n                contentMap[content['@id']] = content;\n            }\n        });\n        var requestedContent = content.result[0][\"@id\"];\n        return {\n            content: contentMap,\n            inlineContent: inlineChildContent({\"@id\": requestedContent}, contentMap),\n            schema: content.schemas,\n            requestedContent: requestedContent\n        };\n    }\n\n    function getQueryVar(variable) {\n        var query = window.location.search.substring(1);\n        var vars = query.split('&');\n        for (var i = 0; i < vars.length; i++) {\n            var pair = vars[i].split('=');\n            if (decodeURIComponent(pair[0]) == variable) {\n                return decodeURIComponent(pair[1]);\n            }\n        }\n        return false;\n    }\n\n    function getQueryVars() {\n        var result = [];\n        var query = window.location.search.substring(1);\n        var vars = query.split('&');\n        for (var i = 0; i < vars.length; i++) {\n            var pair = vars[i].split('=');\n            result.push({key: decodeURIComponent(pair[0]), value: decodeURIComponent(pair[1])});\n        }\n        return result;\n    }\n\n    function parseUrl(){\n        var elm = document.createElement('a');\n        elm.href = window.location.href;\n        return {\n           protocol: elm.protocol,\n           hostname: elm.hostname,\n           port: elm.port,\n           pathname: elm.pathname,\n           search: elm.search,\n           hash: elm.hash,\n           host: elm.host\n        };\n    }\n\n    function parseString(value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        switch (typeof value) {\n            case 'number':\n                return value.toString();\n            case 'string':\n                // ensure string is sanitized (HTML encoded, dangerous chars etc)\n                return sanitize(value);\n            default:\n                return '';\n        }\n    }\n\n    // lifted and gently adjusted from https://github.com/angular/angular.js/blob/v1.3.14/src/ngSanitize/sanitize.js#L435\n    function sanitize(value) {\n        var SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n        // Match everything outside of normal chars and \" (quote character)\n        var NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g;\n\n        return value.\n            replace(/&/g, '&amp;').\n            replace(SURROGATE_PAIR_REGEXP, function(value) {\n                var hi = value.charCodeAt(0);\n                var low = value.charCodeAt(1);\n                return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n            }).\n            replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n                return '&#' + value.charCodeAt(0) + ';';\n            }).\n            replace(/</g, '&lt;').\n            replace(/>/g, '&gt;');\n    }\n\n    function ajaxGet(path) {\n        var def = Q.defer();\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function()\n        {\n            if (xhr.readyState === XMLHttpRequest.DONE) {\n                if (xhr.status === 200) {\n                    def.resolve(xhr.responseText);\n                } else {\n                    def.reject(xhr);\n                }\n            }\n        };\n        xhr.open(\"GET\", path, true);\n        xhr.send();\n        return def.promise;\n    }\n\n}(window.card = window.card?window.card:{}));\n"],"sourceRoot":"/source/"}